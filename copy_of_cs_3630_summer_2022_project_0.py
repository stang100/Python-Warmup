# -*- coding: utf-8 -*-
"""Copy of CS 3630 Summer 2022 Project 0

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1igNk-PLVY6GcmR1KAJdNZtByk-WloCng
"""

# Setup
!pip install gtsam

"""# An Introductory Tour of Python for CS 3630

**Due Mon. May 23 at 11:59pm on gradescope**

## Basic Python

Welcome to CS 3630. We hope you're as excited for this class as we are excited to teach it.

In this assignment, we introduce some basic tools and techniques which will hopefully be useful to you as you tackle all the labs this semester, as well as ensure that you're development environment is set up correctly.

Some of you may already be familiar with all the topics in this assignment, so think of this assignment as more of a "working out the initial gremlins".
"""

import numpy as np
# You don't need GTSAM this project, but it will be used for future projects.
# Take this as an opportunity to check that GTSAM is installed properly if you're not using colab.
import gtsam

"""### Printing

The most fundamental aspect of any programming language is being able to print out values, which is incredibly easy in Python.

Being able to print with nice formatting is particularly helpful in debugging.
"""

print("Welcome to CS 3630")

term = "Summer"
year = 2022
print("This is for {0} {1}".format(term, year))

"""One powerful way to print lots of variables conveniently is to use `f-strings`. `f-strings` stand for format-strings which leverage special syntax for formatting. You specify an `f-string` by prepending the string with an `f` and printing variables in it by specifying the variable name with curly braces, e.g. `{var}`."""

name = "Steve Tang"
fstring =f"This is a f-string to display your name: {name}"
print(fstring)

"""### Looping

A lot of operations involve for-loops, which in python is very idiomatic.

(Note this code is for demonstrative purposes only - normally you would just use `sum(x)`)
"""

x = [1, 3, 5, 7]

vanilla_sum = 0
for i in range(len(x)):
    #TODO Add code to sum the values in x here
    vanilla_sum += x[i]

print(vanilla_sum)

"""However, you may want to use the `enumerate` built-in method for most of your loops as it lets you iterate through elements while also providing an index into them.

Why don't you try adding the line of code to do that? It should be very similar to the above loop statement.
"""

sum = 0
for i, d in enumerate(x):
    sum += d

assert sum == vanilla_sum
print(sum)

"""Things like `if-else` statememts, classes, and functions are pretty much the same as any other programming language you've used in the past, so we won't spend too much time on those.

### Comprehensions & Lambdas

List comprehensions are a powerful tool to make your code more succinct and easier to read.

Say you want to filter out all the even numbers from a list into a new list, this is easily done with a list comprehension.
"""

x = list(range(20))

evens = [c for c in x if c % 2 == 0]
print(evens)

"""Let's see if you can generate the first 8 Mersenne numbers using a list comprehension. A Mersenne number is a number that is of the form $M_n = 2^n - 1$.

**NOTE** 0 is not a Mersenne number (since its binary representation is not all 1s), so be sure to adjust your loop range accordingly.
"""

x = list(range(1,9))
mersennes = [pow(2,c) - 1 for c in x] #TODO Add a list comprehension here to generate the first 8 Mersenne numbers.
assert mersennes == [1, 3, 7, 15, 31, 63, 127, 255], f"Your code produced {mersennes}"

"""## Numpy

### Vectors & Matrices

The most fundamental data structure in python is an `ndarray` which is short for n-dimensional array (also called a `tensor`). You can easily make any list/tuple into an `ndarray` using the following two methods: `np.array` & `np.asarray`. The main difference between the two is that `np.array` creates a copy when the input is already an `ndarray` and so is a bit less efficient than `np.asarray`.
"""

x = list(range(10))

y = np.array(x)
z = np.asarray(x)

print(y)
print(z)
# We can assert that they are truly equal.
assert np.all(y == z)

"""Most of the time, you'll want to create a matrix or vector that is all zeros or ones. The methods for these are `np.zeros` & `np.ones`, both of which accept the expected shape."""

zero_vector = np.zeros(10)
assert zero_vector.shape == (10,)

ones_matrix = np.ones((2, 5))
assert ones_matrix.shape == (2, 5)

zero_points = np.zeros((3,15)) #TODO Create a zeros matrix of size 3x15
assert zero_points.shape == (3, 15) and np.all(zero_points == 0), f"Incorrect shape {zero_points.shape} or has non-zero elements"

one_stack = np.ones((10,6)) #TODO  Create a ones matrix of size 10x6
assert one_stack.shape == (10, 6) and np.all(one_stack == 1), f"Incorrect shape {one_stack.shape} or has non-one elements"

"""You may need some structured vectors or matrices, such as a sequence vector or the identity matrix. Those are simple as well."""

seq = np.arange(1, 10)  # Vector from 1-9

I_3x3 = np.eye(3)  # A 3x3 identity matrix
I_4x4 = np.eye(4) #TODO Create a 4x4 identity matrix
assert I_4x4.shape == (4, 4) and np.all(np.diag(I_4x4) == 1) and np.all(I_4x4[~np.eye(4, dtype=bool)] == 0), f"I_4x4 is not a valid identity matrix."

"""### Indexing

Indexing in `numpy` is slightly different from indexing in traditional python. In `numpy`, you specify the indices all within the same box brackets. The range semantics (e.g. `[0:10]`) are still the same though.
"""

I_6x6 = np.eye(6)

# Get the bottom-right 3x3 submatrix
I_3x3 = I_6x6[3:6, 3:6]

assert np.all(I_3x3 == np.eye(3))

X = np.asarray(I_6x6)
X[5, 0] = 12
X[0, 5] = 99

bottom_left = X[3:6,0:3] 
print (bottom_left) #TODO Get the bottom left submatrix of X
assert np.all(bottom_left == np.asarray([[0, 0, 0], [0, 0, 0], [12, 0, 0]])), f"Incorrect submatrix indexing"

"""### Shapes & Broadcasting

Many times, just knowing the shape of your matrix can help in figuring out what the correct operation should be. This is easily achievable with the `shape` method.
"""

x = np.empty((10, 12))
shape = x.shape #TODO Call the shape method on x to get the correct value
assert shape == (10, 12), f"Incorrect shape received, expected (10, 12)"

"""Once you know the current shape, sometimes you may want to add a single (or maybe multiple) dimension. This is particularly common in `numpy` where vectors are represented as shape `(N,)` and are different from shape `(N,1)` (which is a Nx1 matrix), even though they both have the same number of elements.

Sometimes you want to work with the latter, so you can reshape it easily:
"""

N = 10
x = np.arange(N)
assert x.shape == (N,)

x1 = x.reshape((N, 1))
assert x1.shape == (N, 1)

x2 = x.reshape((1,N)) #TODO reshape x to (1, N)
assert x2.shape == (1, N), f"x2 has shape {x2.shape}, expected (1, 10)"

"""Other times, you just want to add a dimension for a quick operation, such as matrix-matrix multiplication. You can add new dimensions by indexing with `np.newaxis` or, more conveniently, `None`."""

x = np.arange(10)
x1 = x[:, None]

assert x1.shape == (10, 1)

y = np.arange(20)
y11 = y[np.newaxis,:,np.newaxis] #TODO Add two dimensions, one before and one after the main vector dimension
assert y11.shape == (1, 20, 1), f"Incorrect dimensions {y11.shape}, should be (1, 20, 1)"

"""### Arithmetic Operations

In general, prefer performing arithmetic on arrays using __vectorized__ code over `for` loops because numpy vectorized arithmetic is orders of magnitude faster.
"""

# Don't worry about understanding this block of code; it's just to measure the execution speed.
from time import perf_counter
from contextlib import contextmanager
@contextmanager
def measure_time(msg) -> float:
    start = perf_counter()
    yield lambda: perf_counter() - start
    print(f'{msg:10s} took {perf_counter() - start:.6f} seconds')

x = np.arange(1e5)
y = np.arange(2e5, 3e5)

# Bad
with measure_time('Bad') as _:
    z = []
    for i in range(len(x)):
        z.append(x[i] + y[i])
    z = np.array(z)

# Still bad
with measure_time('Still Bad') as _:
    z = np.zeros(x.shape)
    for i, (xi, yi) in enumerate(zip(x, y)):
        z[i] = xi + yi

# Best
with measure_time('Best') as _:
    z = x + y

"""Most matrix/vector arithmetic is element-wise, with one important exception being general matrix multiplication (gemm), which is defined using the `@` operator in `numpy`.  gemm is the workhorse of linear algebra and, by consequence, robotics."""

x = np.asarray([10., 20, 30])
y = np.asarray([1., 2, 3])
I_4x4 = np.eye(3)
print(f'x = {x}')
print(f'y = {y}')
print(f'x + y = {x + y}')
print(f'x - y = {x - y}')
print(f'x * y = {x * y}')
print(f'x / y = {x / y}')
print(f'I_4x4 @ x = {I_4x4 @ x}')
print(f'np.sum(x) = {np.sum(x)}')
print(f'np.prod(x) = {np.prod(x)}')

O = np.ones((1, 3))
sum_x = x @ O.reshape((3,1)) # TODO: Without using `sum`, use gemm to calculate the sum of the elements in x.
assert sum_x == np.sum(x), f"You computed sum_x = {sum_x}, but should be {np.sum(x)}"

"""### Broadcasting

Broadcasting is one the most powerful aspects of `numpy`, but is also tricky to understand. The best way to understand it is to try to use it as much as possible and gain an intuitive feeling for it.

This feature allows you to specify matrices/vectors of different sizes (albeit with some conditions) and operate on them together. A common example is element-wise matrix vector product as shown below. Be sure to checkout the [numpy broadcasting basics page](https://numpy.org/doc/stable/user/basics.broadcasting.html) for more details!
"""

X = np.array([[0, 0, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 2, 0],
       [0, 0, 0, 3],
       [0, 0, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 2, 0],
       [0, 0, 0, 3],
       [0, 0, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 2, 0],
       [0, 0, 0, 3]])

assert X.shape == (12, 4)
scale = np.arange(6, 10)  # shape is (4,)

# Broadcasting scale (4,) to (12, 4) for element-wise multiplication
Y = X * scale

assert np.all(Y == np.tile(np.diag([0, 7, 16, 27]), 3).T), f"Scaled values are incorrect"

"""### Random Sampling

To finish up, we will look at examples of sampling from probability distributions commonly employed when you wish to generate random numbers.

#### Generate a matrix of random values

Sometimes you just need some random values sampled uniformly from `[0, 1]`. This is easy to do with `np.random.random_sample` which follows the same semantics as `np.ones`.
"""

R = np.random.random_sample((3, 3))
print(R)

"""#### Samples from the Normal Distribution

The Gaussian/Normal distribution is the most common probability distribution used in robotics due to it having some very nice properties, one of which is ease of sampling.

We can sample from both a standard Gaussian, as well as a custom Gaussian.
"""

std_samples = np.random.standard_normal((3, 3))
print(std_samples)

# The first argument is the mean, the second is the standard deviation
# We specify the standard deviation to be 1.0 which is pretty tight around the mean.
# This means that the samples won't be too far away from the mean value aka 5
custom_gaussian = np.random.normal(5, 1.0, (3, 3))
print(custom_gaussian)

"""#### Sampling choices

Finally, one common scenario is having to choose from a set of options, e.g. should you move or not move, should you pick object A, B or C, etc.
This is where the `choice` method is useful since it allows you to sample discrete values easily.
"""

rng = np.random.default_rng()

# Give us 6 random choices from 0-9 without replacement
choices = rng.choice(10, size=6, replace=False)
print("Choices without replacement:", choices)

# Give us 7 random choices from 20-29 with replacement
choices = rng.choice(np.arange(20, 30), size=7, replace=True)
#NOTE you may or may not see duplicates, because it is (pseudo-)random!
print("Choices with replacement:", choices)

# Sample random actions for the robot
actions = ['move forward', 'move right', 'move left', 'move backward']
samples = rng.choice(actions, size=3, replace=True)
print(samples)

"""### Conclusion

Hopefully you find this quick tour of `python` and `numpy` informative and useful. A lot of the tips and tricks here should serve you well during the course and beyond it, making you both a very competent Python programmer as well as a roboticist.

Looking forward to having you in the class!
"""